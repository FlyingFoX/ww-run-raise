#!/bin/bash
# Usage: ww -f "window class filter" -c "run if not found"
# Usage: ww -fa "window title filter" -c "run if not found"
# Usage: ww -ia
# Usage: (other ones, please see the help of this script)

TOGGLE="false"
POSITIONAL=()
while [[ $# -gt 0 ]]; do
	key="$1"

	case $key in
	-c | --command)
		COMMAND="$2"
		shift # past argument
		shift # past value
		;;
	-f | --filter)
		FILTERBY="$2"
		shift # past argument
		shift # past value
		;;
	-fa | --filter-alternative)
		FILTERALT="$2"
		shift # past argument
		shift # past value
		;;
	-t | --toggle)
		TOGGLE="true"
		shift # past argument
		;;
	-h | --help)
		HELP="1"
		shift # past argument
		shift # past value
		;;
	-ia | --info-active)
		INFO_ACTIVE="1"
		shift # past argument
		;;			
	*)                  # unknown option
		POSITIONAL+=("$1") # save it in an array for later
		shift              # past argument
		;;
	esac
done

set -- "${POSITIONAL[@]}" # restore positional parameters

if [ -n "$HELP" ]; then
	cat <<EOF
ww. Utility to launch a window (or raise it, if it was minimized), or to show information about the active window, or to perform other operations with windows in KDE Plasma. It interacts with KWin using KWin scripts and it is compatible with X11 and Wayland.

Parameters:

-h  --help                show this help
-ia --info-active         show information about the active window. Using this parameter, this program can be periodically called from
                          other programs, so the user is able to know how much time he/she spends using particular windows, or the user 
                          is able to stop (in order to save CPU use, bandwith or downloaded MBs) programs when they are not in the
                          foreground, etc.
-f  --filter              filter by window class
-fa --filter-alternative  filter by window title (caption)
-t  --toggle              also minimize the window if it is already active
-c  --command             command to check if running and run if no process is found
EOF
	exit 0
fi

if [ -n "$INFO_ACTIVE" ]; then
    kwinSupportInfo="$(qdbus org.kde.KWin /KWin supportInformation)" || exit 1
    kwinVersion="$(awk '/KWin version:/ {print $3}' <<< "$kwinSupportInfo")" || exit 1
    kwinMajorVersion="$(awk -F"." '{print $1}' <<< "$kwinVersion")" || exit 1    
    # This feature needs at least this KWin version
    readonly minimumVersion=6 || exit 1
    if [[ "$kwinMajorVersion" -lt "$minimumVersion" ]]; then
        echo "ERROR: This feature needs KWin $minimumVersion or later." >&2 
        exit 1
    fi

    # This way is similar to the one used on https://discuss.kde.org/t/xdotool-replacement-on-wayland/7242/9
    jsFile="$(mktemp)" || exit 1   # It is the file where the javascript code is going to be saved
    echo "print(\"$jsFile\",workspace.activeWindow.internalId);" > "$jsFile" || exit 1
    
    scriptId="$(qdbus org.kde.KWin /Scripting loadScript "$jsFile")" || exit 1
    timestamp="$(date +"%Y-%m-%d %H:%M:%S")" || exit 1
    # Starts the script
    qdbus org.kde.KWin /Scripting/Script"$scriptId" run || exit 1
    
    # Uses some arguments that are also seen on https://github.com/jinliu/kdotool/blob/master/src/main.rs
    outputJournalctl="$(journalctl --since "$timestamp" --user --user-unit=plasma-kwin_wayland.service --user-unit=plasma-kwin_x11.service --output=cat -g "js: $jsFile")" || exit 1
    # Uses `awk` separately in order to avoid masking a return value, as Shellcheck recommends
    windowId="$(awk '{print $3}' <<< "$outputJournalctl")" || exit 1
    # Stops the script
    qdbus org.kde.KWin /Scripting/Script"$scriptId" stop || exit 1
    
    # Shows the information about that window
    qdbus org.kde.KWin /KWin org.kde.KWin.getWindowInfo "$windowId" || exit 1
    
    exit 0
fi

SCRIPT_TEMPLATE=$(
	cat <<EOF
function kwinactivateclient(clientClass, clientCaption, toggle) {
  var clients = workspace.clientList();
  var compareToCaption = new RegExp(clientCaption || '', 'i');
  var compareToClass = clientClass;
  var isCompareToClass = clientClass.length > 0
  for (var i=0; i<clients.length; i++) {
      var client = clients[i];
      var classCompare = (isCompareToClass && client.resourceClass == compareToClass)
      var captionCompare = (!isCompareToClass && compareToCaption.exec(client.caption))
      if (classCompare || captionCompare) {
          if (workspace.activeClient != client) {
              workspace.activeClient = client;
          } else if (toggle) {
              client.minimized = true;
          }
          break;
      }
  }
}
kwinactivateclient('CLASS_NAME', 'CAPTION_NAME', TOGGLE);
EOF
)

CURRENT_SCRIPT_NAME=$(basename "$0")

# ensure the script file exists
function ensure_script {
	if [ ! -f SCRIPT_PATH ]; then
		if [ ! -d "$SCRIPT_FOLDER" ]; then
			mkdir -p "$SCRIPT_FOLDER"
		fi
		SCRIPT_CONTENT=${SCRIPT_TEMPLATE/CLASS_NAME/$1}
		SCRIPT_CONTENT=${SCRIPT_CONTENT/CAPTION_NAME/$2}
        SCRIPT_CONTENT=${SCRIPT_CONTENT/TOGGLE/$3}
		#if [ "$1" == "class" ]; then
		#SCRIPT_CONTENT=${SCRIPT_CLASS_NAME/REPLACE_ME/$2}
		#else
		#SCRIPT_CONTENT=${SCRIPT_CAPTION/REPLACE_ME/$2}
		#fi
		echo "$SCRIPT_CONTENT" >"$SCRIPT_PATH"
	fi
}

if [ -z "$FILTERBY" ] && [ -z "$FILTERALT" ]; then
	echo "If you want that this program find a window, you need to specify a window filter â€” either by class (\`-f\`) or by title (\`-fa\`). More information can be seen if this script is called using the \`--help\` parameter."
	exit 1
fi

IS_RUNNING=$(pgrep -o -a -f "$COMMAND" | grep -v "$CURRENT_SCRIPT_NAME")

if [ -n "$IS_RUNNING" ] || [ -n "$FILTERALT" ]; then

	# trying for XDG_CONFIG_HOME first
	SCRIPT_FOLDER_ROOT=$XDG_CONFIG_HOME
	if [[ -z $SCRIPT_FOLDER_ROOT ]]; then
		# fallback to the home folder
		SCRIPT_FOLDER_ROOT=$HOME
	fi

	SCRIPT_FOLDER="$SCRIPT_FOLDER_ROOT/.wwscripts/"
	SCRIPT_NAME=$(echo "$FILTERBY$FILTERALT" | md5sum | head -c 32)
	SCRIPT_PATH="$SCRIPT_FOLDER$SCRIPT_NAME"
	ensure_script "$FILTERBY" "$FILTERALT" "$TOGGLE"

	SCRIPT_NAME="ww$RANDOM"
	#SCRIPT_NAME=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 32 | head -n 1)

	# install the script
	ID=$(dbus-send --session --dest=org.kde.KWin --print-reply=literal /Scripting org.kde.kwin.Scripting.loadScript "string:$SCRIPT_PATH" "string:$SCRIPT_NAME" | awk '{print $2}')
	# run it - some KDEs version use Script.run others Scripting.run
	dbus-send --session --dest=org.kde.KWin --print-reply=literal "/$ID" org.kde.kwin.Scripting.run >/dev/null 2>&1
	dbus-send --session --dest=org.kde.KWin --print-reply=literal "/$ID" org.kde.kwin.Script.run >/dev/null 2>&1
	# stop it - some KDEs version use Script.run others Scripting.run
	dbus-send --session --dest=org.kde.KWin --print-reply=literal "/$ID" org.kde.kwin.Scripting.stop >/dev/null 2>&1
	dbus-send --session --dest=org.kde.KWin --print-reply=literal "/$ID" org.kde.kwin.Script.stop >/dev/null 2>&1
	# uninstall it
	dbus-send --session --dest=org.kde.KWin --print-reply=literal /Scripting org.kde.kwin.Scripting.unloadScript "string:$SCRIPT_NAME" >/dev/null 2>&1
elif [ -n "$COMMAND" ]; then
	$COMMAND &
fi
